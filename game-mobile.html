<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>数字掉落游戏 - 测试版</title>
    <style>
        body { margin: 0; padding: 10px; font-family: Arial; background: #faf8ef; touch-action: manipulation; }
        .game-container { max-width: 400px; margin: 0 auto; text-align: center; }
        .game-board { 
            width: 320px; height: 477px; 
            border: 2px solid #bbada0; 
            margin: 20px auto; 
            position: relative; 
            background: #cdc1b4;
            touch-action: none;
        }
        .block { 
            position: absolute; 
            width: 50px; height: 50px; 
            border-radius: 6px; 
            display: flex; align-items: center; justify-content: center;
            font-weight: bold; font-size: 18px;
            transition: all 0.3s;
        }
        .controls { margin: 20px 0; }
        button { 
            padding: 15px 25px; margin: 8px; 
            font-size: 18px; border: none; 
            border-radius: 8px; cursor: pointer;
            background: #8f7a66; color: white;
            min-height: 50px;
        }
        button:active { background: #9f8a76; transform: scale(0.95); }
        .score { font-size: 28px; font-weight: bold; color: #776e65; margin: 15px 0; }
        .touch-hint { font-size: 14px; color: #999; margin: 10px 0; }
    </style>
</head>
<body>
    <div class="game-container">
        <h1>数字掉落游戏</h1>
        <div class="score">分数: <span id="score">0</span></div>
        <div class="touch-hint">滑动控制方块，点击加速下落</div>
        <div class="game-board" id="gameBoard"></div>
        <div class="controls">
            <button onclick="moveLeft()">←</button>
            <button onclick="drop()">↓</button>
            <button onclick="moveRight()">→</button>
            <br>
            <button onclick="restart()">重新开始</button>
            <button onclick="saveScore()">保存分数</button>
            <button onclick="showLeaderboard()">排行榜</button>
        </div>
        <div id="leaderboard" style="margin-top: 20px; display: none;">
            <h3>排行榜</h3>
            <div id="leaderboardList"></div>
            <button onclick="hideLeaderboard()">关闭</button>
        </div>
    </div>

    <script>
        let score = 0;
        let currentBlock = null;
        let currentX = 3;
        let currentY = 0;
        let gameBoard = Array(10).fill().map(() => Array(6).fill(0));
        let placedBlocks = [];
        let dropInterval = null;
        let dropSpeed = 500;
        let userId = 'player_' + Math.random().toString(36).substr(2, 9);
        
        const API_BASE = 'http://172.20.10.5:3000';
        
        const colors = {
            2: '#eee4da', 4: '#ede0c8', 8: '#f2b179', 
            16: '#f59563', 32: '#f67c5f', 64: '#f65e3b',
            128: '#edcf72', 256: '#edcc61', 512: '#edc850',
            1024: '#edc53f', 2048: '#edc22e'
        };
        
        function createBlock(number) {
            const block = document.createElement('div');
            block.className = 'block';
            block.textContent = number;
            block.style.backgroundColor = colors[number] || '#3c3a32';
            block.style.color = number <= 4 ? '#776e65' : 'white';
            return block;
        }
        
        function spawnBlock() {
            if (checkGameOver()) {
                alert('游戏结束！最终分数: ' + score);
                restart();
                return;
            }
            
            const numbers = [2, 4, 8, 16];
            const number = numbers[Math.floor(Math.random() * numbers.length)];
            currentBlock = createBlock(number);
            currentX = 3;
            currentY = 0;
            updateBlockPosition();
            document.getElementById('gameBoard').appendChild(currentBlock);
            
            if (gameBoard[0][currentX] !== 0) {
                alert('游戏结束！最终分数: ' + score);
                restart();
                return;
            }
            
            dropBlock();
        }
        
        function updateBlockPosition() {
            if (currentBlock) {
                currentBlock.style.left = (currentX * 53) + 'px';
                currentBlock.style.top = ((currentY - 1) * 53) + 'px';
                currentBlock.style.display = currentY === 0 ? 'none' : 'flex';
            }
        }
        
        function dropBlock() {
            currentY = 0;
            dropSpeed = 500;
            
            dropInterval = setInterval(() => {
                currentY++;
                if (currentBlock) {
                    currentBlock.style.top = ((currentY - 1) * 53) + 'px';
                    currentBlock.style.display = currentY >= 1 ? 'flex' : 'none';
                }
                
                if (currentY >= 9 || (currentY < 9 && gameBoard[currentY + 1][currentX] !== 0)) {
                    clearInterval(dropInterval);
                    placeBlock();
                    
                    setTimeout(() => {
                        checkMerge();
                        applyGravity();
                        
                        if (checkGameOver()) {
                            // 游戏结束时自动保存分数
                            await autoSaveScore();
                            alert('游戏结束！最终分数: ' + score);
                            restart();
                            return;
                        }
                        
                        spawnBlock();
                    }, 100);
                }
            }, dropSpeed);
        }
        
        function placeBlock() {
            if (currentBlock) {
                const number = parseInt(currentBlock.textContent);
                gameBoard[currentY][currentX] = number;
                
                placedBlocks.push({
                    element: currentBlock,
                    x: currentX,
                    y: currentY,
                    number: number
                });
                
                currentBlock = null;
            }
        }
        
        function checkMerge() {
            let merged = true;
            
            while (merged) {
                merged = false;
                
                for (let y = 9; y >= 1; y--) {
                    for (let x = 0; x < 6; x++) {
                        if (gameBoard[y][x] === 0) continue;
                        
                        const currentNumber = gameBoard[y][x];
                        
                        if (y + 1 < 10 && gameBoard[y + 1][x] === currentNumber) {
                            mergeBlocks(x, y, x, y + 1);
                            merged = true;
                        }
                        else if (x + 1 < 6 && gameBoard[y][x + 1] === currentNumber) {
                            mergeBlocks(x, y, x + 1, y);
                            merged = true;
                        }
                        else if (x - 1 >= 0 && gameBoard[y][x - 1] === currentNumber) {
                            mergeBlocks(x, y, x - 1, y);
                            merged = true;
                        }
                        else if (y - 1 >= 1 && gameBoard[y - 1][x] === currentNumber) {
                            mergeBlocks(x, y, x, y - 1);
                            merged = true;
                        }
                    }
                }
            }
        }
        
        function mergeBlocks(x1, y1, x2, y2) {
            const newNumber = gameBoard[y1][x1] * 2;
            gameBoard[y1][x1] = newNumber;
            gameBoard[y2][x2] = 0;
            
            updateBlockDisplay(x1, y1, newNumber);
            removeBlockDisplay(x2, y2);
            
            score += newNumber;
            document.getElementById('score').textContent = score;
        }
        
        function applyGravity() {
            let moved = true;
            
            while (moved) {
                moved = false;
                
                for (let y = 8; y >= 1; y--) {
                    for (let x = 0; x < 6; x++) {
                        if (gameBoard[y][x] !== 0 && gameBoard[y + 1][x] === 0) {
                            gameBoard[y + 1][x] = gameBoard[y][x];
                            gameBoard[y][x] = 0;
                            
                            moveBlockDisplay(x, y, x, y + 1);
                            moved = true;
                        }
                    }
                }
            }
        }
        
        function moveBlockDisplay(fromX, fromY, toX, toY) {
            const block = findBlockAt(fromX, fromY);
            if (block) {
                block.x = toX;
                block.y = toY;
                block.element.style.left = (toX * 53) + 'px';
                block.element.style.top = ((toY - 1) * 53) + 'px';
            }
        }
        
        function checkGameOver() {
            for (let x = 0; x < 6; x++) {
                if (gameBoard[1][x] !== 0) {
                    return true;
                }
            }
            return false;
        }
        
        function updateBlockDisplay(x, y, number) {
            const block = findBlockAt(x, y);
            if (block) {
                block.element.textContent = number;
                block.element.style.backgroundColor = colors[number] || '#3c3a32';
                block.element.style.color = number <= 4 ? '#776e65' : 'white';
                block.number = number;
                block.element.style.left = (x * 53) + 'px';
                block.element.style.top = ((y - 1) * 53) + 'px';
            }
        }
        
        function removeBlockDisplay(x, y) {
            const blockIndex = placedBlocks.findIndex(b => b.x === x && b.y === y);
            if (blockIndex !== -1) {
                placedBlocks[blockIndex].element.remove();
                placedBlocks.splice(blockIndex, 1);
            }
        }
        
        function findBlockAt(x, y) {
            return placedBlocks.find(b => b.x === x && b.y === y);
        }
        
        function moveLeft() {
            if (currentBlock && currentX > 0) {
                currentX--;
                updateBlockPosition();
            }
        }
        
        function moveRight() {
            if (currentBlock && currentX < 5) {
                currentX++;
                updateBlockPosition();
            }
        }
        
        function drop() {
            if (dropInterval && currentBlock) {
                clearInterval(dropInterval);
                dropSpeed = 50;
                
                dropInterval = setInterval(() => {
                    currentY++;
                    if (currentBlock) {
                        currentBlock.style.top = ((currentY - 1) * 53) + 'px';
                        currentBlock.style.display = currentY >= 1 ? 'flex' : 'none';
                    }
                    
                    if (currentY >= 9 || (currentY < 9 && gameBoard[currentY + 1][currentX] !== 0)) {
                        clearInterval(dropInterval);
                        placeBlock();
                        
                        setTimeout(() => {
                            checkMerge();
                            applyGravity();
                            
                        if (checkGameOver()) {
                            // 游戏结束时自动保存分数
                            await autoSaveScore();
                            alert('游戏结束！最终分数: ' + score);
                            restart();
                            return;
                        }
                            
                            spawnBlock();
                        }, 100);
                    }
                }, dropSpeed);
            }
        }
        
        function restart() {
            score = 0;
            document.getElementById('score').textContent = score;
            document.getElementById('gameBoard').innerHTML = '';
            gameBoard = Array(10).fill().map(() => Array(6).fill(0));
            placedBlocks = [];
            if (dropInterval) clearInterval(dropInterval);
            spawnBlock();
        }
        
        async function autoSaveScore() {
            if (score > 0) {
                try {
                    const response = await fetch(`${API_BASE}/score`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            userId: userId,
                            score: score,
                            timestamp: Date.now()
                        })
                    });
                    
                    const result = await response.json();
                    console.log('分数自动保存成功');
                } catch (error) {
                    console.error('自动保存失败:', error);
                }
            }
        }
        
        async function saveScore() {
            try {
                const response = await fetch(`${API_BASE}/score`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        userId: userId,
                        score: score,
                        timestamp: Date.now()
                    })
                });
                
                const result = await response.json();
                alert('分数保存成功！');
            } catch (error) {
                console.error('保存分数失败:', error);
                alert('保存失败，请检查后端服务是否启动');
            }
        }
        
        async function showLeaderboard() {
            try {
                const response = await fetch(`${API_BASE}/leaderboard`);
                const data = await response.json();
                
                const leaderboardDiv = document.getElementById('leaderboard');
                const listDiv = document.getElementById('leaderboardList');
                
                listDiv.innerHTML = '';
                
                if (data.leaderboard && data.leaderboard.length > 0) {
                    data.leaderboard.forEach((item, index) => {
                        const div = document.createElement('div');
                        div.innerHTML = `${index + 1}. ${item.userId}: ${item.score}分`;
                        div.style.padding = '5px';
                        div.style.borderBottom = '1px solid #ccc';
                        listDiv.appendChild(div);
                    });
                } else {
                    listDiv.innerHTML = '<div>暂无排行榜数据</div>';
                }
                
                leaderboardDiv.style.display = 'block';
            } catch (error) {
                console.error('获取排行榜失败:', error);
                alert('获取排行榜失败，请检查后端服务');
            }
        }
        
        function hideLeaderboard() {
            document.getElementById('leaderboard').style.display = 'none';
        }
        
        // 触摸控制
        let touchStartX = 0;
        let touchStartY = 0;
        
        document.getElementById('gameBoard').addEventListener('touchstart', (e) => {
            e.preventDefault();
            touchStartX = e.touches[0].clientX;
            touchStartY = e.touches[0].clientY;
        });
        
        document.getElementById('gameBoard').addEventListener('touchend', (e) => {
            e.preventDefault();
            const touchEndX = e.changedTouches[0].clientX;
            const touchEndY = e.changedTouches[0].clientY;
            
            const deltaX = touchEndX - touchStartX;
            const deltaY = touchEndY - touchStartY;
            
            if (Math.abs(deltaX) > Math.abs(deltaY)) {
                if (deltaX > 30) {
                    moveRight();
                } else if (deltaX < -30) {
                    moveLeft();
                }
            } else {
                if (deltaY > 30) {
                    drop();
                } else if (Math.abs(deltaX) < 20 && Math.abs(deltaY) < 20) {
                    drop();
                }
            }
        });
        
        // 键盘控制
        document.addEventListener('keydown', (e) => {
            switch(e.key) {
                case 'ArrowLeft': moveLeft(); break;
                case 'ArrowRight': moveRight(); break;
                case 'ArrowDown': drop(); break;
            }
        });
        
        // 启动游戏
        spawnBlock();
        console.log('用户ID:', userId);
    </script>
</body>
</html>